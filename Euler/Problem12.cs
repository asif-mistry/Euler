using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

/*
Highly divisible triangular number
Problem 12

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
Answer : 76576500
 * 
 * time taken: around 3 hours for first method
 * 
 * 
 * Explanation::www.mathblog.dk/triangle-number-with-more-than-500-divisors/
 */

namespace Euler
{
    class Problem12
    {
        public void answerProblem()
        {
            bool answerFound = false;

            int i = 1; //last know nums I +1
            int numberOfDivisors = 500;
            int num = 0; //last known Num

            int loopCount = 0;
            
            while (answerFound == false)
            {
                //iterate through all triangle numbers
                num = num + i;
                int divsorCount = getDivisorCount(num, out loopCount);

                if (divsorCount > numberOfDivisors)
                    answerFound = true;
                Console.WriteLine("Triangle Number ==" + num + " Divisor count ==" + divsorCount + "  Position = " + i);
                i++;
            }

            Console.WriteLine(num + " is the first triangle number to have over five hundred divisors");
            Console.WriteLine("LOOPCOUNT ==== "+loopCount);

        }

        private int getDivisorCount(int num, out int loopCount)
        {
            loopCount = 0;
            int divisorCount = 1; //as one is always the divisor
            if (num == divisorCount)
            {
                return divisorCount;
            }

            int sqrt = (int)Math.Sqrt(num);
            int compare = num / 2;
            for (int i = 2; i <= sqrt; i++)
            {
                if (num % i == 0)
                    divisorCount+=2;
                
                loopCount++;
            }
            //Correction if the number is a perfect square
            if (sqrt * sqrt == num)
            {
                divisorCount--;
            }
            divisorCount++;//as the number to get the divisor is always the divisor

            return divisorCount;
        }

        //using Prime method
        private ulong getDivisorCount2(ulong num, out int loopCount)
        {
            loopCount = 0;
            ulong divisorCount = 1; //as one is always the divisor
            if (num == divisorCount)
                return divisorCount;

            List<ulong> divisorList = new List<ulong>();
            divisorList.Add(divisorCount);
            List<ulong> primeList = Prime.getPrimeList((ulong)num);
            
            foreach (ulong i in primeList)
            {
                for (ulong j = (ulong)i; j <= num / 2; j=j+(ulong)i)
                {
                    if (num % j == 0)
                    {
                        if (!divisorList.Contains(j))
                            divisorList.Add(j);
                    }
                    loopCount++;
                }
            }

            divisorCount = (ulong)divisorList.Count;

            divisorCount++;//as the number to get the divisor is always the divisor

            return divisorCount;
        }
        
    }
}
